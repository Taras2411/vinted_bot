============================================================
FILE: .\main.py
============================================================

import asyncio
import signal
import sys

from core.shutdown import shutdown_event
from parser.parser_service import scheduler_loop
from bot import start_bot
from bot.notifier import notifier_loop
from db import init_db, close_db, get_db


def request_shutdown():
    if not shutdown_event.is_set():
        print("Shutdown signal received")
        shutdown_event.set()


def setup_signal_handlers():
    """
    –ö—Ä–æ—Å—Å–ø–ª–∞—Ç—Ñ–æ—Ä–º–µ–Ω–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–∏–≥–Ω–∞–ª–æ–≤
    """
    try:
        loop = asyncio.get_running_loop()

        # Linux / macOS (systemd)
        for sig in (signal.SIGINT, signal.SIGTERM):
            loop.add_signal_handler(sig, request_shutdown)

    except (NotImplementedError, RuntimeError):
        # Windows fallback
        signal.signal(signal.SIGINT, lambda s, f: request_shutdown())
        signal.signal(signal.SIGTERM, lambda s, f: request_shutdown())


async def main():
    await init_db()
    print("Database initialized.")
    db = await get_db()

    setup_signal_handlers()

    tasks = [
        asyncio.create_task(start_bot(db, shutdown_event)),
        asyncio.create_task(scheduler_loop(db, shutdown_event)),
        asyncio.create_task(notifier_loop(db, shutdown_event)),
    ]

    try:
        # –∂–¥—ë–º –ø–æ–∫–∞ –∫—Ç–æ-—Ç–æ –≤—ã—Å—Ç–∞–≤–∏—Ç shutdown_event
        await shutdown_event.wait()

    finally:
        print("Shutting down...")

        for task in tasks:
            task.cancel()

        # –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –¥–æ–∂–∏–¥–∞–µ–º—Å—è –æ—Ç–º–µ–Ω—ã
        await asyncio.gather(*tasks, return_exceptions=True)

        await close_db()
        print("Shutdown complete")


if __name__ == "__main__":
    asyncio.run(main())


============================================================
FILE: .\test.py
============================================================

# test how get_user_searches works with user_id from get_user_by_tg_id for tg_id 720318208. use connection for main db
import asyncio
from db import init_db, close_db, get_db
from db.repositories import get_user_by_tg_id, get_user_searches
async def test_get_user_searches():
    await init_db()
    db = await get_db()
    try:
        tg_id = 720318208
        user = await get_user_by_tg_id(db, tg_id)
        if user:
            user_id = user['id']
            searches = await get_user_searches(db, user_id)
            searches_list = [dict(row) for row in searches]
            print(f"Searches for user_id {user_id} (tg_id {tg_id}): {searches_list}")
        else:
            print(f"No user found with tg_id {tg_id}")
    finally:
        await close_db()

if __name__ == "__main__":
    asyncio.run(test_get_user_searches())

============================================================
FILE: .\bot\bot_logic.py
============================================================

from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import Message
import asyncio
from db import (get_db, close_db)

from db.repositories import *
from bot.config import BOT_TOKEN as TOKEN

# Initialize bot and dispatcher
bot = Bot(token=TOKEN)
dp = Dispatcher()

async def start_bot(db, shutdown_event):
    print("Starting bot...")
    dp["db"] = db

    # FIX: handle_signals=False prevents aiogram from hijacking Ctrl+C
    polling_task = asyncio.create_task(dp.start_polling(bot, handle_signals=False))

    await shutdown_event.wait()

    print("Stopping bot...")
    polling_task.cancel()
    
    # Cleanly wait for the polling task to finish
    try:
        await polling_task
    except asyncio.CancelledError:
        pass
        
    await bot.session.close()

@dp.message(Command("start"))
async def cmd_start(message: Message):
    await message.answer(
        "Welcome to Vinted Bot! ü§ñ\n"
        "Use /help to see available commands."
    )
    # add user to database
    await get_or_create_user(dp["db"], message.from_user.id, message.from_user.username)




@dp.message(Command("help"))
async def cmd_help(message: Message):
    await message.answer(
        "/start - Start the bot\n"
        "/help - Show this help message\n"
        "/add_search <vinted_url> <title> - Add a new search\n"
        "/remove_search <id> - Remove a search by ID\n"
        "/list_searches - List all your searches"
    )


@dp.message(Command("add_search"))
async def cmd_add_search(message: Message):
    db = dp["db"]
    args = message.text.split(maxsplit=2)
    if len(args) < 3:
        await message.answer("Usage: /add_search <vinted_url> <title>")
        return
    vinted_url = args[1]
    title = args[2]
    try:
        user = await get_user_by_tg_id(db, message.from_user.id)
        if not user:
            await message.answer("You are not registered yet. Use /start to register.")
            return
        user_id = user['id']
        search = await add_search(db, user_id, title, vinted_url)
        await message.answer(f"‚úÖ Search added with ID: {search['id']}")
    except Exception as e:
        await message.answer(f"‚ùå Error: {str(e)}")



@dp.message(Command("remove_search"))
async def cmd_remove_search(message: Message):
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer("Usage: /remove_search <id>")
        return
    
    try:
        search_id = int(args[1])
        await remove_search(dp["db"], search_id)
        await message.answer(f"‚úÖ Search removed!")
    except ValueError:
        await message.answer("Invalid search ID")
    except Exception as e:
        await message.answer(f"‚ùå Error: {str(e)}")


@dp.message(Command("list_searches"))
async def cmd_list_searches(message: Message):
    try:
        user_id = await get_user_by_tg_id(dp["db"], message.from_user.id)
        if not user_id:
            await message.answer("You are not registered yet. Use /start to register.")
            return
        searches = await get_user_searches(dp["db"], user_id['id'])
        if not searches:
            await message.answer("No searches yet")
            return
        
        response = "üìã Your searches:\n\n"
        for search in searches:
            response += f"ID: {search['id']} - {search['title']} - {search['vinted_url']}\n"
        await message.answer(response)
    except Exception as e:
        await message.answer(f"‚ùå Error: {str(e)}")


# send notification function
async def send_notification(user_id: int, text: str, image_url: str = None):
    try:
        if image_url:
            await bot.send_photo(chat_id=user_id, photo=image_url, caption=text)
        else:
            await bot.send_message(chat_id=user_id, text=text)
    except Exception as e:
        print(f"Failed to send message to {user_id}: {e}")

============================================================
FILE: .\bot\config.py
============================================================

BOT_TOKEN = "8389178046:AAGvUXZKVjf6mCdM3i2aQkQ3nXq1_mIO1Xw"
PARSER_INTERVAL_MINUTES = 0.5
NOTIFIER_INTERVAL_MINUTES = 0.5
TELEGRAM_NOTIFICATIONS_INTRVAL_MS = 1000

============================================================
FILE: .\bot\notifier.py
============================================================

from db.repositories import *
import asyncio
from .bot_logic import *
from .config import NOTIFIER_INTERVAL_MINUTES as M
from .config import TELEGRAM_NOTIFICATIONS_INTRVAL_MS as T


async def notifier_loop(db, shutdown_event: asyncio.Event):
    while not shutdown_event.is_set():
        try:
            searches = await get_active_searches(db)

            for search in searches:
                unsent_items = await get_unsent_items_for_search(db, search["id"])

                for item in unsent_items:
                    tg_id = await get_tg_id_by_user_id(db, search["user_id"])

                    await send_notification(
                        tg_id,
                        item["title"] + "\n" +
                        item["price"] + "\n" +
                        item["url"] + "\n" +
                        item["brand"],
                        item["image_url"]
                    )

                    await mark_item_as_sent(db, search["id"], item["id"])

                    # üî¥ –ó–ê–î–ï–†–ñ–ö–ê –ú–ï–ñ–î–£ –°–û–û–ë–©–ï–ù–ò–Ø–ú–ò
                    await asyncio.sleep(T / 1000)

            await asyncio.wait_for(shutdown_event.wait(), timeout=M * 60)

        except asyncio.TimeoutError:
            continue
        except Exception as e:
            print(f"Error in notifier_loop: {e}")
            await asyncio.sleep(60)


============================================================
FILE: .\bot\__init__.py
============================================================

from .bot_logic import *
from .config import *
from .notifier import notifier_loop

============================================================
FILE: .\core\shutdown.py
============================================================

import asyncio

shutdown_event = asyncio.Event()

============================================================
FILE: .\core\__init__.py
============================================================



============================================================
FILE: .\db\database.py
============================================================

import aiosqlite
from pathlib import Path

# –ø—É—Ç—å –¥–æ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
BASE_DIR = Path(__file__).resolve().parent.parent
DB_PATH = BASE_DIR / "data" / "vinted.db"

# –≥–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ (–æ–¥–Ω–æ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ)
_db: aiosqlite.Connection | None = None


async def get_db() -> aiosqlite.Connection:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ë–î.
    –°–æ–∑–¥–∞—ë—Ç –µ–≥–æ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –≤—ã–∑–æ–≤–µ.
    """
    global _db

    if _db is None:
        _db = await aiosqlite.connect(DB_PATH)
        await _db.execute("PRAGMA foreign_keys = ON;")
        await _db.execute("PRAGMA journal_mode=WAL;")
        _db.row_factory = aiosqlite.Row

    return _db


async def init_db() -> None:
    """
    –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö:
    - —Å–æ–∑–¥–∞—ë—Ç –ø–∞–ø–∫—É data/
    - –ø—Ä–∏–º–µ–Ω—è–µ—Ç schema.sql
    """
    DB_PATH.parent.mkdir(parents=True, exist_ok=True)

    db = await get_db()

    schema_path = BASE_DIR / "db" / "schema.sql"
    with open(schema_path, "r", encoding="utf-8") as f:
        await db.executescript(f.read())

    await db.commit()


async def close_db() -> None:
    """
    –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ –∑–∞–∫—Ä—ã–≤–∞–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ë–î
    (–≤—ã–∑—ã–≤–∞—Ç—å –ø—Ä–∏ shutdown –±–æ—Ç–∞)
    """
    global _db

    if _db is not None:
        await _db.close()
        _db = None

if __name__ == "__main__":
    import asyncio

    async def main():
        await init_db()
        print("Database initialized.")
        # stop code here
        await close_db()

    asyncio.run(main())

============================================================
FILE: .\db\__init__.py
============================================================

from .database import (
    get_db,
    init_db,
    close_db,
)


============================================================
FILE: .\db\repositories\items.py
============================================================

from aiosqlite import Connection

async def add_item(
    db: Connection,
    vinted_id: int,
    title: str,
    price: int,
    url: str,
    image_url: str | None,
    brand: str | None,
    created_at: str | None,
):
    # –ü—ã—Ç–∞–µ–º—Å—è –≤—Å—Ç–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å
    async with db.execute(
        """
        INSERT INTO items (
            vinted_id, title, price, url, image_url, brand, created_at
        )
        VALUES (?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(vinted_id) DO NOTHING
        RETURNING id;
        """,
        (vinted_id, title, price, url, image_url, brand, created_at),
    ) as cursor:
        row = await cursor.fetchone()
    
    if row:
        await db.commit()
        return row["id"]

    # –ï—Å–ª–∏ –∑–∞–ø–∏—Å—å —É–∂–µ –±—ã–ª–∞ (ON CONFLICT —Å—Ä–∞–±–æ—Ç–∞–ª), –ø–æ–ª—É—á–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π id
    async with db.execute(
        "SELECT id FROM items WHERE vinted_id = ?;",
        (vinted_id,),
    ) as cursor:
        row = await cursor.fetchone()
        return row["id"]

============================================================
FILE: .\db\repositories\searches.py
============================================================

from aiosqlite import Connection

async def add_search(
    db: Connection,
    user_id: int,
    title: str,
    vinted_url: str,
):
    async with db.execute(
        """
        INSERT INTO searches (user_id, title, vinted_url)
        VALUES (?, ?, ?)
        RETURNING *;
        """,
        (user_id, title, vinted_url),
    ) as cursor:
        row = await cursor.fetchone()
    
    await db.commit()
    return row

async def get_user_searches(db: Connection, user_id: int):
    async with db.execute(
        """
        SELECT * FROM searches
        WHERE user_id = ? AND active = 1
        ORDER BY created_at DESC;
        """,
        (user_id,),
    ) as cursor:
        return await cursor.fetchall()

async def get_active_searches(db: Connection):
    async with db.execute(
        "SELECT * FROM searches WHERE active = 1;"
    ) as cursor:
        return await cursor.fetchall()

async def deactivate_search(db: Connection, search_id: int):
    async with db.execute(
        "UPDATE searches SET active = 0 WHERE id = ?;",
        (search_id,),
    ) as cursor:
        pass
    await db.commit()

async def activate_search(db: Connection, search_id: int):
    async with db.execute(
        "UPDATE searches SET active = 1 WHERE id = ?;",
        (search_id,),
    ) as cursor:
        pass
    await db.commit()

async def remove_search(db: Connection, search_id: int):
    async with db.execute(
        "DELETE FROM searches WHERE id = ?;",
        (search_id,),
    ) as cursor:
        pass
    await db.commit()

============================================================
FILE: .\db\repositories\search_items.py
============================================================

from aiosqlite import Connection

async def link_item_to_search(
    db: Connection,
    search_id: int,
    item_id: int,
):
    async with db.execute(
        """
        INSERT OR IGNORE INTO search_items (search_id, item_id)
        VALUES (?, ?);
        """,
        (search_id, item_id),
    ) as cursor:
        pass
    await db.commit()

async def get_unsent_items_for_search(
    db: Connection,
    search_id: int,
):
    async with db.execute(
        """
        SELECT i.*
        FROM items i
        JOIN search_items si ON si.item_id = i.id
        WHERE si.search_id = ?
          AND si.sent = 0;
        """,
        (search_id,),
    ) as cursor:
        return await cursor.fetchall()

async def mark_item_as_sent(
    db: Connection,
    search_id: int,
    item_id: int,
):
    async with db.execute(
        """
        UPDATE search_items
        SET sent = 1,
            sent_at = CURRENT_TIMESTAMP
        WHERE search_id = ?
          AND item_id = ?;
        """,
        (search_id, item_id),
    ) as cursor:
        pass
    await db.commit()

============================================================
FILE: .\db\repositories\users.py
============================================================

from aiosqlite import Connection

async def get_or_create_user(
    db: Connection,
    tg_id: int,
    username: str | None = None,
):
    async with db.execute(
        """
        INSERT INTO users (tg_id, username)
        VALUES (?, ?)
        ON CONFLICT(tg_id) DO UPDATE SET
            username = excluded.username
        RETURNING id;
        """,
        (tg_id, username),
    ) as cursor:
        row = await cursor.fetchone()
    
    await db.commit()
    return row["id"]

async def get_user_by_tg_id(db: Connection, tg_id: int):
    async with db.execute(
        "SELECT * FROM users WHERE tg_id = ?;",
        (tg_id,),
    ) as cursor:
        return await cursor.fetchone()

async def get_tg_id_by_user_id(db: Connection, user_id: int):
    async with db.execute(
        "SELECT tg_id FROM users WHERE id = ?;",
        (user_id,),
    ) as cursor:
        row = await cursor.fetchone()
        if row:
            return row["tg_id"]
    return None

============================================================
FILE: .\db\repositories\__init__.py
============================================================

from .users import *
from .searches import *
from .items import *
from .search_items import *

============================================================
FILE: .\parser\parser.py
============================================================

from playwright.async_api import async_playwright
from dataclasses import dataclass
from typing import Optional
import re
import asyncio




@dataclass
class VintedItem:
    """Class representing a Vinted item"""
    url: str
    parsed_title: Optional['titleParsed'] = None
    brand_id: Optional[int] = None
    image_src: Optional[str] = None
    vinted_id: Optional[int] = None
    
    def __repr__(self) -> str:
        return f"VintedItem(title='{self.title}')"
    
@dataclass
class titleParsed:
    """Class representing a parsed title"""
    name: str
    brand : Optional[str] = None
    condition: Optional[str] = None
    size: Optional[str] = None
    price: Optional[str] = None

def extract_vinted_id(href: str) -> Optional[int]:
    """Extract Vinted ID from item href URL"""
    if not href:
        return None
    match = re.search(r'/items/(\d+)', href)
    return int(match.group(1)) if match else None


def title_parser(title: str) -> titleParsed:
    # example of unparsed title: Dƒõtsk√Ω Nike batoh nov√Ω, znaƒçka: Nike, stav: Nov√Ω s visaƒçkou, velikost: Univerz√°ln√≠, 400,00 Kƒç, 438,00 Kƒç vƒçetnƒõ Ochrany kupuj√≠c√≠ch

    
    name = None
    brand = None
    condition = None
    size = None
    price = None
    
    # Extract prices with currency (handles decimal comma separator)
    # Pattern: number,number currency (e.g., "400,00 Kƒç")
    price_pattern = r'(\d+,\d+\s+\w+)'
    prices = re.findall(price_pattern, title)
    
    # Get second price if available, otherwise first price
    if len(prices) >= 2:
        price = prices[1]
    elif len(prices) == 1:
        price = prices[0]
    
    # Remove prices from title for easier field extraction
    title_without_prices = re.sub(price_pattern, '', title).strip()
    
    # Split by comma and process fields
    parts = [part.strip() for part in title_without_prices.split(',')]
    
    # First part is the name
    if parts:
        name = parts[0]
    
    # Parse other fields
    for part in parts[1:]:
        if part.startswith('znaƒçka:'):
            brand = part.replace('znaƒçka:', '').strip()
        elif part.startswith('stav:'):
            condition = part.replace('stav:', '').strip()
        elif part.startswith('velikost:'):
            size = part.replace('velikost:', '').strip()
    
    return titleParsed(
        name=name or "",
        brand=brand,
        condition=condition,
        size=size,
        price=price
    )
    

async def parse_vinted(URL: Optional[str] = None) -> list[VintedItem]:
    # get brand id from URL
    brand_id = re.search(r'brand_ids\[\]=(\d+)', URL)
    brand_id_int = int(brand_id.group(1)) if brand_id else None
    async with async_playwright() as p:
        browser = await p.chromium.launch(
            headless=True,
            args=[
                "--disable-blink-features=AutomationControlled"
            ]
        )
        context = await browser.new_context(
            locale="cs-CZ",
            user_agent=(
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                "AppleWebKit/537.36 (KHTML, like Gecko) "
                "Chrome/120.0.0.0 Safari/537.36"
            )
        )
        page = await context.new_page()

        await page.goto(URL, wait_until="networkidle")

        # –ñ–¥—ë–º, –ø–æ–∫–∞ React –æ—Ç—Ä–∏—Å—É–µ—Ç –∫–∞—Ä—Ç–æ—á–∫–∏
        await page.wait_for_selector(
            ".feed-grid__item",
            timeout=15000
        )

        items = await page.query_selector_all(
            ".feed-grid__item"
        )

        print(f"–ù–∞–π–¥–µ–Ω–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: {len(items)}")

        # Parse items into VintedItem objects
        vinted_items = []
        for item in items:
            # Find the overlay element within this feed-grid__item
            overlay = await item.query_selector(".new-item-box__overlay.new-item-box__overlay--clickable")
            if not overlay:
                continue
            
            href = await overlay.get_attribute("href")
            title = await overlay.get_attribute("title")
            
            # Find the image element within this feed-grid__item
            image_elem = await item.query_selector("img.web_ui__Image__content")
            image_src = await image_elem.get_attribute("src") if image_elem else None
            
            
            parsedTitle = title_parser(title) if title else None
            vinted_id = extract_vinted_id(href)
            vinted_item = VintedItem(url=href, parsed_title=parsedTitle, brand_id=brand_id_int, image_src=image_src, vinted_id=vinted_id)
            vinted_items.append(vinted_item)

        await browser.close()
        return vinted_items



============================================================
FILE: .\parser\parser_service.py
============================================================

import asyncio
import time
from aiosqlite import Connection
from db.repositories import (
    get_active_searches,
    add_item,
    link_item_to_search,
)
from parser.parser import parse_vinted
from bot.config import PARSER_INTERVAL_MINUTES as N

# –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –û–î–ù–û–í–†–ï–ú–ï–ù–ù–û –æ—Ç–∫—Ä—ã—Ç—ã—Ö –±—Ä–∞—É–∑–µ—Ä–æ–≤ (—á—Ç–æ–±—ã –Ω–µ —Å—ä–µ–ª–æ RAM)
MAX_CONCURRENT_PARSERS = 5
browser_semaphore = asyncio.Semaphore(MAX_CONCURRENT_PARSERS)

# –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –¥–ª—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö (–ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç "SQL statements in progress")
db_lock = asyncio.Lock()

async def process_search(db: Connection, search: dict):
    start_time = time.perf_counter()
    search_id = search['id']
    
    try:
        # 1. –ü–ê–†–ê–õ–õ–ï–õ–¨–ù–´–ô –ü–ê–†–°–ò–ù–ì
        async with browser_semaphore:
            print(f"[INFO] –ù–∞—á–∏–Ω–∞—é –ø–∞—Ä—Å–∏–Ω–≥: {search['title']} (ID {search_id})")
            items = await parse_vinted(search["vinted_url"])
        
        if not items:
            print(f"[INFO] –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –¥–ª—è ID {search_id}")
            return

        # 2. –ü–û–°–õ–ï–î–û–í–ê–¢–ï–õ–¨–ù–ê–Ø –ó–ê–ü–ò–°–¨ –í –ë–î (–ø–æ–¥ –∑–∞—â–∏—Ç–æ–π Lock)
        async with db_lock:
            for item in items:
                # –í–ê–ñ–ù–û: –í –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è—Ö commit —É–±—Ä–∞–Ω –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏
                item_id = await add_item(
                    db,
                    vinted_id=item.vinted_id,
                    title=item.parsed_title.name if item.parsed_title else None,
                    price=item.parsed_title.price if item.parsed_title else None,
                    url=item.url,
                    image_url=item.image_src,
                    brand=item.parsed_title.brand if item.parsed_title else None,
                    created_at=None,
                )
                await link_item_to_search(db, search_id, item_id)
            
            # –û–¥–∏–Ω –∫–æ–º–º–∏—Ç –Ω–∞ –≤–µ—Å—å —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤ ‚Äî —ç—Ç–æ –û–ß–ï–ù–¨ –±—ã—Å—Ç—Ä–æ
            await db.commit()
            
        execution_time = time.perf_counter() - start_time
        print(f"[SUCCESS] –ü–æ–∏—Å–∫ ID {search_id} –æ–±—Ä–∞–±–æ—Ç–∞–Ω. –ù–∞–π–¥–µ–Ω–æ: {len(items)}. –í—Ä–µ–º—è: {execution_time:.2f}—Å")

    except Exception as e:
        print(f"[ERROR] –û—à–∏–±–∫–∞ –≤ –ø–æ–∏—Å–∫–µ {search_id}: {e}")

async def scheduler_loop(db: Connection, shutdown_event: asyncio.Event):
    print(f"[INFO] –¶–∏–∫–ª –ø–∞—Ä—Å–∏–Ω–≥–∞ –∑–∞–ø—É—â–µ–Ω. –ò–Ω—Ç–µ—Ä–≤–∞–ª: {N} –º–∏–Ω.")
    
    while not shutdown_event.is_set():
        try:
            searches = await get_active_searches(db)
            
            if not searches:
                print("[INFO] –ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–∏—Å–∫–æ–≤ –Ω–µ—Ç.")
            else:
                print(f"[INFO] –ó–∞–ø—É—Å–∫–∞—é {len(searches)} –ø–æ–∏—Å–∫–æ–≤...")
                # –ó–∞–ø—É—Å–∫–∞–µ–º –≤—Å–µ –ø–æ–∏—Å–∫–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
                tasks = [process_search(db, search) for search in searches]
                await asyncio.gather(*tasks)

        except Exception as e:
            print(f"[ERROR] –û—à–∏–±–∫–∞ –≤ scheduler_loop: {e}")

        try:
            await asyncio.wait_for(shutdown_event.wait(), timeout=N * 60)
        except asyncio.TimeoutError:
            continue

    print("[INFO] –¶–∏–∫–ª –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")

============================================================
FILE: .\parser\__init__.py
============================================================

from .parser import parse_vinted


